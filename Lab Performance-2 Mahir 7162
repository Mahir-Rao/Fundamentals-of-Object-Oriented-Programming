Task-1:

Suppose you are working on a geometry library that deals with different types of geometric shapes, including circles, rectangles, and triangles. 
Each shape has common properties like area and perimeter, but also specific attributes such as radius for circles, length and width for rectangles, and side lengths for triangles.

•	Develop a class hierarchy for geometric shapes using inheritance in C++.
•	Explain how you would utilize inheritance and polymorphism to implement algorithms for calculating area and perimeter that are specific to each type of shape

#include <iostream>
#include <cmath>

using namespace std;

// Inheritance allows derived shape classes (Circle, Rectangle, etc.) to inherit common methods from a base Shape class, such as area() and perimeter(). Polymorphism ensures that the correct area and perimeter calculations specific to each shape are executed at runtime, using the overridden methods.

class Shape {
public:
    double area() {
        return 0.0;
    }

    double perimeter() {
        return 0.0;
    }
};

class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) {
        radius = r;
    }

    double area() {
        return M_PI * radius * radius;
    }

    double perimeter() {
        return 2 * M_PI * radius;
    }

    double getradius() {
        return radius;
    }
};

class Rectangle : public Shape {
private:
    double length;
    double width;

public:
    Rectangle(double l, double w) {
        length = l;
        width = w;
    }

    double area() {
        return length * width;
    }

    double perimeter() {
        return 2 * (length + width);
    }

    double getlength() {
        return length;
    }

    double getwidth() {
        return width;
    }
};

int main() {
    Circle circle(5);
    Rectangle rectangle(4, 6);

    cout << "Circle - Radius: " << circle.getradius() << endl;
    cout << "Circle - Area: " << circle.area() << endl;
    cout << "Circle - Perimeter: " << circle.perimeter() << endl;

    cout << "\nRectangle - Length: " << rectangle.getlength() << ", Width: " << rectangle.getwidth() << endl;
    cout << "Rectangle - Area: " << rectangle.area() << endl;
    cout << "Rectangle - Perimeter: " << rectangle.perimeter() << endl;

    return 0;
}


Task-2:

An operator overloading allows custom behavior to be defined for built-in operators like addition (+), subtraction (-), when we used with user-defined types.
When overloading binary operators as friend functions, external functions can access private members of a class.
Provide examples how binary operator overloading is implemented using friend functions. 

#include <iostream>

using namespace std;

class Point {
private:
    int x, y;

public:
    Point(int x = 0, int y = 0) {
        this->x = x;
        this->y = y;
    }

    friend Point operator+(Point& p1, Point& p2);

    void display() {
        cout << "x: " << x << ", y: " << y << endl;
    }
};

Point operator+(Point& p1, Point& p2) {
    Point temp;
    temp.x = p1.x + p2.x;
    temp.y = p1.y + p2.y;
    return temp;
}

class Complex {
private:
    double real, imaginary;

public:
    Complex(double real = 0.0, double imaginary = 0.0) {
        this->real = real;
        this->imaginary = imaginary;
    }

    friend Complex operator-(Complex& c1, Complex& c2);

    void display() {
        cout << real << " + " << imaginary << "i" << endl;
    }
};

Complex operator-( Complex& c1, Complex& c2) {
    Complex temp;
    temp.real = c1.real - c2.real;
    temp.imaginary = c1.imaginary - c2.imaginary;
    return temp;
}

int main() {
    
    Point p1(2, 3);
    Point p2(4, 5);

    Point p3 = p1 + p2; 

    cout << "Point Example:" << endl;
    p3.display(); 
    cout << endl;

    Complex c1(5.5, 4.5);
    Complex c2(2.5, 1.5);

    Complex c3 = c1 - c2; 

    cout << "Complex Example:" << endl;
    c3.display(); 

    return 0;
}
